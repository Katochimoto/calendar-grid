var __$injectStyle = (function () {
  var exportObject = {
  "97797357": {
    "MonthWeekEvent": "MonthWeekEvent___22Ndd",
    "MonthWeekEvent_Content": "MonthWeekEvent_Content___3Yld9"
  },
  "125746737": {
    "InfiniteList": "InfiniteList___3XqI_",
    "InfiniteList_Content": "InfiniteList_Content___1kOCe",
    "InfiniteList_Content__scrolling": "InfiniteList_Content__scrolling___3CLVJ",
    "InfiniteList_Content__animation": "InfiniteList_Content__animation___33rOd"
  },
  "197916609": {
    "MonthWeek": "MonthWeek___31vIB"
  },
  "213726621": {
    "MonthWeekDay": "MonthWeekDay___1nO3V",
    "MonthWeekDay__weekend": "MonthWeekDay__weekend___25SNX",
    "MonthWeekDay__trbl2": "MonthWeekDay__trbl2___3CuSR",
    "MonthWeekDay__trbl6": "MonthWeekDay__trbl6___1xPir",
    "MonthWeekDay__trbl8": "MonthWeekDay__trbl8___3SOlO",
    "MonthWeekDay__trbl9": "MonthWeekDay__trbl9___436TH",
    "MonthWeekDay_DateTitle": "MonthWeekDay_DateTitle___z5qp2",
    "MonthWeekDay_Date": "MonthWeekDay_Date___2tFPr",
    "MonthWeekDay_Month": "MonthWeekDay_Month___15hV5",
    "MonthWeekDay__current": "MonthWeekDay__current___3Qx_A"
  },
  "698411118": {
    "DayHeader": "DayHeader___21sK3",
    "DayHeader__weekend": "DayHeader__weekend___2CR5h",
    "DayHeader_Title": "DayHeader_Title___3oYcF"
  },
  "818803677": {
    "DayEventFolded": "DayEventFolded___1L-rf"
  },
  "1033337454": {
    "DayEvents": "DayEvents___1A1CM"
  },
  "1207401694": {
    "MonthWeekEvents": "MonthWeekEvents___3kc8m"
  },
  "1506717487": {
    "GridDaysItem": "GridDaysItem___26Fit"
  },
  "1705367372": {
    "GridMonthContent": "GridMonthContent___mp4gY"
  },
  "1928509998": {
    "MonthWeekDays": "MonthWeekDays___3laR3"
  },
  "2155886673": {
    "Calendar": "Calendar___2AH7n"
  },
  "2189316770": {
    "DayHours": "DayHours___1LNiW",
    "DayHours_Item": "DayHours_Item___QRxDY"
  },
  "2584529487": {
    "Grid": "Grid___13LWm",
    "Grid__columns7": "Grid__columns7___3i57S",
    "Grid__columns6": "Grid__columns6___3TxrU",
    "Grid__columns5": "Grid__columns5___1jrOl",
    "Grid__columns4": "Grid__columns4___2Ekfk",
    "Grid__columns3": "Grid__columns3___2bvrY",
    "Grid__columns2": "Grid__columns2___3zOZ2",
    "Grid__columns1": "Grid__columns1___2MvqF",
    "Grid__rows10": "Grid__rows10___2FR9I",
    "Grid__rows9": "Grid__rows9___1WqBZ",
    "Grid__rows8": "Grid__rows8___2IILY",
    "Grid__rows7": "Grid__rows7____moJc",
    "Grid__rows6": "Grid__rows6___3lKLt",
    "Grid__rows5": "Grid__rows5___2BaVa",
    "Grid__rows4": "Grid__rows4___33U6i",
    "Grid__rows3": "Grid__rows3___1RH7n",
    "Grid__rows2": "Grid__rows2___2LsEv",
    "Grid__rows1": "Grid__rows1___2ZLvh",
    "Grid_ColumnStart7": "Grid_ColumnStart7___3gG2I",
    "Grid_ColumnStart6": "Grid_ColumnStart6___Idsyc",
    "Grid_ColumnStart5": "Grid_ColumnStart5___26N58",
    "Grid_ColumnStart4": "Grid_ColumnStart4___1wZ5g",
    "Grid_ColumnStart3": "Grid_ColumnStart3___9fqBj",
    "Grid_ColumnStart2": "Grid_ColumnStart2___PZpPc",
    "Grid_ColumnStart1": "Grid_ColumnStart1___a2gU4",
    "Grid_ColumnEnd7": "Grid_ColumnEnd7___1UrU8",
    "Grid_ColumnEnd6": "Grid_ColumnEnd6___-5-Iq",
    "Grid_ColumnEnd5": "Grid_ColumnEnd5___VVh81",
    "Grid_ColumnEnd4": "Grid_ColumnEnd4___gutIS",
    "Grid_ColumnEnd3": "Grid_ColumnEnd3___1WBEv",
    "Grid_ColumnEnd2": "Grid_ColumnEnd2___2x2ll",
    "Grid_ColumnEnd1": "Grid_ColumnEnd1___3iOXl",
    "Grid_RowStart10": "Grid_RowStart10___7zbTm",
    "Grid_RowStart9": "Grid_RowStart9___17nkK",
    "Grid_RowStart8": "Grid_RowStart8___34dDG",
    "Grid_RowStart7": "Grid_RowStart7___1DRJ2",
    "Grid_RowStart6": "Grid_RowStart6___a1Gu0",
    "Grid_RowStart5": "Grid_RowStart5___sRVEQ",
    "Grid_RowStart4": "Grid_RowStart4___2x7Jq",
    "Grid_RowStart3": "Grid_RowStart3___1Xbc8",
    "Grid_RowStart2": "Grid_RowStart2___WAEGo",
    "Grid_RowStart1": "Grid_RowStart1___1aSO9"
  },
  "2728098803": {
    "GridDaysContent": "GridDaysContent___dHdER",
    "GridDaysContent_Scroll": "GridDaysContent_Scroll___28DVF"
  },
  "3216744561": {
    "Day": "Day___16tcs",
    "Day__weekend": "Day__weekend___1wrFr"
  },
  "3231277828": {
    "InfiniteListItem": "InfiniteListItem___1yoQ-",
    "InfiniteListItem__axisX": "InfiniteListItem__axisX___1dMr6"
  },
  "3332231429": {
    "GridMonth": "GridMonth___mjOTy",
    "GridMonth_Header": "GridMonth_Header___3XBEY",
    "GridMonth_Content": "GridMonth_Content___wVKZe"
  },
  "3588246877": {
    "DayEvent": "DayEvent___3ttsO",
    "DayEvent__selected": "DayEvent__selected___1yps_"
  },
  "3987658384": {
    "GridMonthItem": "GridMonthItem___2woIG"
  },
  "4080515877": {
    "GridDaysHeader": "GridDaysHeader___3Jday",
    "GridDaysHeader_Content": "GridDaysHeader_Content___O7nuN",
    "GridDaysHeader_Item": "GridDaysHeader_Item___3oLyn"
  },
  "4237803930": {
    "GridDays": "GridDays___1Oz_n",
    "GridDays_Header": "GridDays_Header___2FUvT",
    "GridDays_Content": "GridDays_Content___2E4G8"
  }
};
  return function (hash) {
    return exportObject[hash];
  };
}());

import React from 'react';
import classnames from 'classnames';

var HOURMS = 60 * 60 * 1000;

var DAYMS = HOURMS * 24;

var WEEKDAYS = 7;

/**
 * Формирование объекта даты из числового представления.
 * @param {number} date
 * @returns {Date}
 */
function parseDate(date) {
  var _ = date / 100 ^ 0;
  var y = date / 10000 ^ 0;
  var m = _ - 100 * y - 1;
  var d = date - _ * 100;
  return new Date(y, m, d, 0, 0, 0, 0);
}

/**
 * Формирование числового представления даты из объекта.
 * @param {Date} date
 * @returns {number}
 */
function formatDate(date) {
  return date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
}

/**
 * Смещение даты на количество дней.
 * @param {number} date
 * @param {number} offset
 * @returns {number}
 */
function offsetOnDay(date, offset) {
  var d = parseDate(date);
  d.setDate(d.getDate() + offset);
  return formatDate(d);
}

/**
 * Смещение даты на количество рабочих дней.
 * Результат не может приходится на выходной.
 * Смещение начинается с первого рабочего дня, если переданное выходной.
 * Выходные игнорируются, если вся неделя не рабочая.
 * @param {number} date
 * @param {number} offset количество рабочих дней
 * @param {Object.<string, number>} weekends объект выходных дней недели
 * @returns {number}
 */
function offsetOnWorksDay(date, offset, weekends) {
  if ( weekends === void 0 ) weekends = {};

  var d = parseDate(date);
  var len = Object.keys(weekends).length;

  if (len > 0 && len < WEEKDAYS) {
    var sig = offset < 0 ? -1 : 1;
    offset = Math.abs(offset);

    var idx = 0;
    while (idx < offset) {
      d.setDate(d.getDate() + sig);
      if (!(d.getDay() in weekends)) {
        idx++;
      }
    }
  } else {
    d.setDate(d.getDate() + offset);
  }

  return formatDate(d);
}

/**
 * День недели.
 * @param {number} date
 * @returns {number}
 */
function getDay(date) {
  return parseDate(date).getDay();
}

function getDate(date) {
  var _ = date / 100 ^ 0;
  return date - _ * 100;
}

/**
 * Первый день месяца.
 * @param {number} date
 * @returns {number}
 */
function getMonthDate(date) {
  var d = parseDate(date);
  d.setDate(1);
  return formatDate(d);
}

function equalToMonth(date1, date2) {
  var y1 = date1 / 10000 ^ 0;
  var m1 = (date1 / 100 ^ 0) - 100 * y1 - 1;
  var y2 = date2 / 10000 ^ 0;
  var m2 = (date2 / 100 ^ 0) - 100 * y2 - 1;

  return y1 === y2 && m1 === m2;
}

function mergeIntervals(intervals) {
  var min = Number.MAX_VALUE;
  var max = Number.MIN_VALUE;

  for (var i = 0, len = intervals.length; i < len; i++) {
    var interval = intervals[i];

    if (Array.isArray(interval[0])) {
      interval = mergeIntervals(interval);
    }

    if (!interval) {
      continue;
    }

    var dateBegin = interval[0];
    var dateEnd = interval[1] || dateBegin;

    if (dateBegin < min) {
      min = dateBegin;
    }

    if (dateEnd > max) {
      max = dateEnd;
    }
  }

  return min === Number.MAX_VALUE || max === Number.MIN_VALUE ? null : [min, max];
}

var DAYS = {
  '0': 'Sun',
  '1': 'Mon',
  '2': 'Tue',
  '3': 'Wed',
  '4': 'Thu',
  '5': 'Fri',
  '6': 'Sat'
};

var MONTH_GEN_SHORT = {
  '1': 'Янв.',
  '2': 'Фев.',
  '3': 'Мар.',
  '4': 'Апр.',
  '5': 'Мая',
  '6': 'Июня',
  '7': 'Июля',
  '8': 'Авг.',
  '9': 'Сент.',
  '10': 'Окт.',
  '11': 'Ноя.',
  '12': 'Дек.'
};

var MONTH_GEN_SHORT_LOWER = {
  '1': 'янв',
  '2': 'фев',
  '3': 'мар',
  '4': 'апр',
  '5': 'мая',
  '6': 'июня',
  '7': 'июля',
  '8': 'авг',
  '9': 'сент',
  '10': 'окт',
  '11': 'ноя',
  '12': 'дек'
};

var Strategy = (function () {
  function Strategy () {}

  Strategy.prototype.destroy = function destroy () {};

  Strategy.prototype.gridDaysHourTitle = function gridDaysHourTitle (hour) {
    return hour === 0 ? '12am' : hour < 12 ? (hour + "am") : hour == 12 ? '12pm' : ((hour - 12) + "pm");
  };

  Strategy.prototype.gridDaysDayTitle = function gridDaysDayTitle (date) {
    return ((DAYS[date.getDay()]) + ", " + (date.getDate()) + " " + (MONTH_GEN_SHORT_LOWER[date.getMonth() + 1]));
  };

  Strategy.prototype.monthNameGenShort = function monthNameGenShort (date) {
    return MONTH_GEN_SHORT[date.getMonth() + 1];
  };

  return Strategy;
}());

var Datetime = (function () {
  function Datetime(strategy) {
    this._strategy = strategy || new Strategy();
  }

  Datetime.prototype.destroy = function destroy () {
    if (this._strategy) {
      this._strategy.destroy();
      this._strategy = null;
    }
  };

  Datetime.prototype.gridDaysHourTitle = function gridDaysHourTitle (hour) {
    return this._strategy.gridDaysHourTitle(hour);
  };

  Datetime.prototype.gridDaysDayTitle = function gridDaysDayTitle (date) {
    return this._strategy.gridDaysDayTitle(parseDate(date));
  };

  Datetime.prototype.monthNameGenShort = function monthNameGenShort (date) {
    return this._strategy.monthNameGenShort(parseDate(date));
  };

  /**
   * День недели.
   * @param {number} date
   * @returns {number}
   */
  Datetime.prototype.getDay = function getDay$1 (date) {
    return getDay(date);
  };

  Datetime.prototype.getDate = function getDate$1 (date) {
    return getDate(date);
  };

  Datetime.prototype.parseDate = function parseDate$1 (date) {
    return parseDate(date);
  };

  Datetime.prototype.formatDate = function formatDate$1 (date) {
    return formatDate(date);
  };

  Datetime.prototype.offsetOnDay = function offsetOnDay$1 (date, offset) {
    return offsetOnDay(date, offset);
  };

  return Datetime;
}());

var context$1 = (function () {
  /* eslint no-eval: 0 */
  return this || (1, eval)('this');
})();

var CALLBACKS = [];

function lazy(target, key, descriptor) {
  return _lazyDecorator(context$1.setImmediate, target, key, descriptor);
}





function qlazy(callback) {
  if (!CALLBACKS.length) {
    context$1.setTimeout(_qlazyRun, 200);
  }

  callback.cancel = function () { return _qlazyCancel(callback); };
  CALLBACKS.push(callback);
  return callback;
}

function _qlazyCancel(callback) {
  var i = 0;
  while (i < CALLBACKS.length) {
    if (CALLBACKS[i] === callback) {
      CALLBACKS.splice(i, 1);
    } else {
      i++;
    }
  }
}

function _qlazyRun() {
  var task;
  while (task = CALLBACKS.shift()) {
    task();
  }
}

function _lazyDecorator(flazy, target, key, descriptor) {
  var callback = descriptor.value;
  callback._args = [];

  var _lazyRun = function () {
    var saveArgs = callback._args;
    callback._timer = 0;
    callback._args = [];
    callback.call(this, saveArgs);
  };

  descriptor.value = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    args.length && callback._args.push(args);

    if (!callback._timer) {
      var that = this;
      callback._timer = flazy(function _lazy() {
        _lazyRun.call(that);
      });
    }
  };

  descriptor.value.displayName = key;

  return descriptor;
}

var _class$1;

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var EventEmitter = (_class$1 = (function () {
  function EventEmitter() {
    this._callbacks = [];
  }

  EventEmitter.prototype.destroy = function destroy () {
    this._callbacks = [];
  };

  EventEmitter.prototype.emitChangeSync = function emitChangeSync () {
    var this$1 = this;

    var len = this._callbacks.length;
    var i = 0;

    for (; i < len; i++) {
      var item = this$1._callbacks[i];
      if (item[1]) {
        item[0].call(item[1]);
      } else {
        item[0]();
      }
    }
  };

  EventEmitter.prototype.emitChange = function emitChange () {
    this.emitChangeSync();
  };

  EventEmitter.prototype.addChangeListener = function addChangeListener (callback, ctx) {
    this.removeChangeListener(callback, ctx);
    this._callbacks.push([callback, ctx]);
  };

  EventEmitter.prototype.removeChangeListener = function removeChangeListener (callback, ctx) {
    var this$1 = this;

    var i = 0;
    while (i < this._callbacks.length) {
      var item = this$1._callbacks[i];
      if (item[0] === callback && item[1] === ctx) {
        this$1._callbacks.splice(i, 1);
      } else {
        i++;
      }
    }
  };

  return EventEmitter;
}()), (_applyDecoratedDescriptor(_class$1.prototype, 'emitChange', [lazy], Object.getOwnPropertyDescriptor(_class$1.prototype, 'emitChange'), _class$1.prototype)), _class$1);

var F_ID = 'id';
var F_UPDATED = 'updated';
var F_DATE_BEGIN = 'dateBegin';
var Event = (function (EventEmitter$$1) {
  function Event(data) {
    EventEmitter$$1.call(this);
    this._data = data;
    this._next = null;
    this._prev = null;
  }

  if ( EventEmitter$$1 ) Event.__proto__ = EventEmitter$$1;
  Event.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Event.prototype.constructor = Event;

  Event.prototype.destroy = function destroy () {
    EventEmitter$$1.prototype.destroy.call(this);
    this._data = null;
    this._next = null;
    this._prev = null;
  };

  Event.prototype.get = function get (name) {
    return this._data && this._data[name];
  };

  Event.prototype.getId = function getId () {
    return this.get(F_ID);
  };

  Event.prototype.next = function next () {
    return this._next;
  };

  Event.prototype.prev = function prev () {
    return this._prev;
  };

  Event.prototype.setPrevNext = function setPrevNext (prev, next) {
    this._prev = prev;
    this._next = next;
    return this;
  };

  Event.prototype.setNext = function setNext (next) {
    this._next = next;
    return this;
  };

  Event.prototype.setPrev = function setPrev (prev) {
    this._prev = prev;
    return this;
  };

  Event.prototype.valueOf = function valueOf () {
    return this.get(F_UPDATED);
  };

  Event.prototype.toString = function toString () {
    return String(this.valueOf() || '');
  };

  Event.prototype.compareBeginInInterval = function compareBeginInInterval (interval) {
    var dateBegin = interval[0];
    var dateEnd = interval[1] || dateBegin;
    var evtDateBegin = this.get(F_DATE_BEGIN);

    return evtDateBegin < dateBegin ? -1 : evtDateBegin > dateEnd ? 1 : 0;
  };

  Event.prototype.isBeginInInterval = function isBeginInInterval (interval) {
    return this.compareBeginInInterval(interval) === 0;
  };

  Event.prototype.first = function first () {
    var item;
    var current = this;

    do {
      item = current;
      current = current.prev();
    } while (current);

    return item || null;
  };

  Event.prototype.last = function last () {
    var item;
    var current = this;

    do {
      item = current;
      current = current.next();
    } while (current);

    return item || null;
  };

  Event.prototype.firstByInterval = function firstByInterval (interval) {
    var item;
    var toFirst = true;
    var current = this;

    while (current && !item) {
      var compare = current.compareBeginInInterval(interval);

      if (compare === -1) {
        current = current.next();
        toFirst = false;
      } else if (compare === 1) {
        current = current.prev();
        toFirst = true;
      } else if (toFirst) {
        var prev = current.prev();
        if (prev) {
          current = prev;
        } else {
          item = current;
        }
      } else {
        item = current;
      }
    }

    return item || null;
  };

  Event.prototype.lastByInterval = function lastByInterval (interval) {
    var item;
    var toLast = true;
    var current = this;

    while (current && !item) {
      var compare = current.compareBeginInInterval(interval);

      if (compare === -1) {
        current = current.next();
        toLast = true;
      } else if (compare === 1) {
        current = current.prev();
        toLast = false;
      } else if (toLast) {
        var next = current.next();
        if (next) {
          current = next;
        } else {
          item = current;
        }
      } else {
        item = current;
      }
    }

    return item || null;
  };

  Event.prototype.prevByInterval = function prevByInterval (interval) {
    var item = this.firstByInterval(interval);
    item = item && item.prev();

    if (!item) {
      var last = this.last();
      if (last && last.compareBeginInInterval(interval) === -1) {
        item = last;
      }
    }

    return item;
  };

  Event.prototype.nextByInterval = function nextByInterval (interval) {
    var item = this.lastByInterval(interval);
    item = item && item.next();

    if (!item) {
      var first = this.first();
      if (first && first.compareBeginInInterval(interval) === 1) {
        item = first;
      }
    }

    return item;
  };

  return Event;
}(EventEmitter));

var _class$2;

function _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var Strategy$1 = (_class$2 = (function (EventEmitter$$1) {
  function Strategy(ref) {
    if ( ref === void 0 ) ref = {};
    var upload = ref.upload;
    var update = ref.update;

    EventEmitter$$1.call(this);
    this._state = Object.create(null);
    this._current = null;
    this._upload = upload || (function () {});
    this._update = update || (function () {});
  }

  if ( EventEmitter$$1 ) Strategy.__proto__ = EventEmitter$$1;
  Strategy.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Strategy.prototype.constructor = Strategy;

  Strategy.prototype.destroy = function destroy () {
    var this$1 = this;

    EventEmitter$$1.prototype.destroy.call(this);

    for (var eventId in this$1._state) {
      var event = this$1._state[eventId];
      if (event) {
        event.destroy();
      }
    }

    this._state = Object.create(null);
    this._current = null;
    this._upload = function () {};
    this._update = function () {};
  };

  Strategy.prototype.getEventInstance = function getEventInstance (data) {
    if (data instanceof Event) {
      return data;
    }

    var newEvent = new Event(data);
    var eventId = newEvent.getId();
    var prevEvent = this._state[eventId];

    if (prevEvent) {
      if (prevEvent.valueOf() === newEvent.valueOf()) {
        return prevEvent;
      } else {
        this.destroyEventInstance(prevEvent);
      }
    }

    this._state[eventId] = newEvent;
    return newEvent;
  };

  Strategy.prototype.destroyEventInstance = function destroyEventInstance (event) {
    this._state[event.getId()] = undefined;
    event.destroy();
  };

  Strategy.prototype.getByInterval = function getByInterval (interval) {
    var item = this._current && this._current.firstByInterval(interval);

    return {
      next: function next() {
        var data = { done: true, value: undefined };

        if (item && item.isBeginInInterval(interval)) {
          data.done = false;
          data.value = item;
          item = item.next();
        }

        return data;
      }
    };
  };

  Strategy.prototype.clearByInterval = function clearByInterval (interval) {
    var first = this._current && this._current.prevByInterval(interval) || null;
    var last = this._current && this._current.nextByInterval(interval) || null;

    if (first) {
      first.setNext(last);
    }

    if (last) {
      last.setPrev(first);
    }

    return [first, last];
  };

  Strategy.prototype.uploadByInterval = function uploadByInterval (intervals) {
    var interval = mergeIntervals(intervals);
    this._upload(interval, this._uploadCallback);
  };

  Strategy.prototype._uploadCallback = function _uploadCallback (error, interval, data) {
    if (error || !data.length) {
      return;
    }

    var ref = this.clearByInterval(interval);
    var first = ref[0];
    var last = ref[1];

    var events = data.map(this.getEventInstance, this).map(createEventLinks);

    if (first) {
      first.setNext(events[0]);
      events[0].setPrev(first);
    }

    if (last) {
      last.setPrev(events[events.length - 1]);
      events[events.length - 1].setNext(last);
    }

    this._current = events[0];
    this.emitChange();
  };

  return Strategy;
}(EventEmitter)), (_applyDecoratedDescriptor$1(_class$2.prototype, 'uploadByInterval', [lazy], Object.getOwnPropertyDescriptor(_class$2.prototype, 'uploadByInterval'), _class$2.prototype)), _class$2);
function createEventLinks(event, idx, events) {
  return event.setPrevNext(events[idx - 1] || null, events[idx + 1] || null);
}

var Events = (function (EventEmitter$$1) {
  function Events(strategy) {
    EventEmitter$$1.call(this);
    this._setStrategy(strategy);
  }

  if ( EventEmitter$$1 ) Events.__proto__ = EventEmitter$$1;
  Events.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Events.prototype.constructor = Events;

  Events.prototype.destroy = function destroy () {
    EventEmitter$$1.prototype.destroy.call(this);
    if (this._strategy) {
      this._strategy.destroy();
      this._strategy = undefined;
    }
  };

  Events.prototype.setStrategy = function setStrategy (strategy) {
    this._setStrategy(strategy);
    // this.emitChange();
  };

  Events.prototype.getByInterval = function getByInterval (interval) {
    return this._strategy.getByInterval(interval);
  };

  Events.prototype.uploadByInterval = function uploadByInterval (interval) {
    var this$1 = this;

    return qlazy(function () { return this$1._strategy.uploadByInterval(interval); });
  };

  Events.prototype._handleChangeStrategy = function _handleChangeStrategy () {
    this.emitChange();
  };

  Events.prototype._setStrategy = function _setStrategy (strategy) {
    if (this._strategy) {
      this._strategy.destroy();
    }

    this._strategy = strategy || new Strategy$1();
    this._strategy.addChangeListener(this._handleChangeStrategy, this);
  };

  return Events;
}(EventEmitter));

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();















var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var StoreStrategy = (function () {
  function StoreStrategy(data) {
  var this$1 = this;
  if ( data === void 0 ) data = {};

    this.current = _extends({}, data);
    this.isChanged = false;
    this.state = Object.create(null);

    /*::`*/
    var props = Object.keys(data).reduce(function (data, name) {
      var gname = "_" + name + "Getter";

      var prop = data[name] = {
        enumerable: true
      };

      prop.get = gname in this$1 ? function () { return this$1[gname](); } : function () { return this$1.current[name]; };

      prop.get.displayName = gname;

      if (name !== name.toUpperCase()) {
        var sname = "_" + name + "Setter";

        prop.set = sname in this$1 ? function (value) { return this$1[sname](value); } : function (value) {
          this$1.current[name] = value;
          this$1.isChanged = true;
        };

        prop.set.displayName = sname;
      }

      return data;
    }, {});

    Object.defineProperties(this.state, props);
    /*::`;*/
  }

  StoreStrategy.prototype.destroy = function destroy () {
    this.current = undefined;
    this.state = undefined;
  };

  StoreStrategy.prototype.update = function update (data) {
    var this$1 = this;

    this.isChanged = false;

    if (!data) {
      return this.isChanged;
    }

    for (var name in data) {
      if (data.hasOwnProperty(name) && name in this$1.state && data[name] !== this$1.state[name]) {
        this$1.state[name] = data[name];
      }
    }

    return this.isChanged;
  };

  return StoreStrategy;
}());

var Store = (function (EventEmitter$$1) {
  function Store(strategy) {
    EventEmitter$$1.call(this);
    this._setStrategy(strategy);
  }

  if ( EventEmitter$$1 ) Store.__proto__ = EventEmitter$$1;
  Store.prototype = Object.create( EventEmitter$$1 && EventEmitter$$1.prototype );
  Store.prototype.constructor = Store;

  Store.prototype.destroy = function destroy () {
    EventEmitter$$1.prototype.destroy.call(this);
    if (this._strategy) {
      this._strategy.destroy();
      this._strategy = undefined;
    }
  };

  Store.prototype.setStrategy = function setStrategy (strategy) {
    this._setStrategy(strategy);
    // this.emitChange();
  };

  Store.prototype.getState = function getState () {
    return this._strategy.state;
  };

  Store.prototype.update = function update (data) {
    if (this._strategy.update(data)) {
      this.emitChange();
    }
  };

  Store.prototype._setStrategy = function _setStrategy (strategy) {
    if (this._strategy) {
      this._strategy.destroy();
    }

    this._strategy = strategy;
  };

  return Store;
}(EventEmitter));

function mixin(mixins) {
  if ( mixins === void 0 ) mixins = [];

  return function (component) {
    var proto = component.prototype;
    mixins.forEach(function (item) { return Object.assign(proto, item); });
  };
}

var ASCROLL = {
  DISABLE: -2,
  OFF: 0,
  ON: 1,
  STOP: -1
};

var GRID = {
  DAY: 'day',
  MONTH: 'month'
};

function toObject(value) {
  var data = {};

  for (var i = 0, len = value.length; i < len; i++) {
    data[value[i]] = i;
  }

  return data;
}

function createIntervals(list, ms) {
  if ( ms === void 0 ) ms = true;

  var intervals = [];
  var common = {};
  var work = {};
  var prev = -2;
  var start = 0;
  var j = 0;

  for (var i = 0, len = list.length; i < len; i++) {
    var item = list[i];
    if (item - prev > 1) {
      start = item;
    }
    work[start] = [item, 0];
    prev = item;
  }

  for (var i$1 in work) {
    i$1 = Number(i$1);
    if (i$1 !== j) {
      common[j] = [i$1 - 1, 1];
    }
    common[i$1] = work[i$1];
    j = work[i$1][0] + 1;
  }

  if (j <= 23) {
    common[j] = [23, 1];
  }

  if (ms) {
    for (var i$2 in common) {
      i$2 = Number(i$2);
      intervals.push([i$2 * HOURMS, (common[i$2][0] + 1) * HOURMS, common[i$2][1]]);
    }
  } else {
    for (var i$3 in common) {
      i$3 = Number(i$3);
      intervals.push([i$3, common[i$3][0] + 1, common[i$3][1]]);
    }
  }

  return intervals;
}

function getColumn(time, columns) {
  for (var i = 0; i < 6; i++) {
    if (columns[i] <= time) {
      return i;
    }
  }

  return columns.length;
}

var HOURS = '0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23';
var HOURS_LIST = HOURS.split(',').map(Number);
var INTERVALS = createIntervals(HOURS_LIST);
var DAYMS$1 = HOURS_LIST.length * HOURMS;
var GRID_HOURS = toObject(HOURS_LIST);

var WEEKENDS = '0,6';
var WEEKENDS_SET = toObject(WEEKENDS.split(',').map(Number));

var stateGrid = {
  grid: GRID.DAY,
  scaleY: 200,

  //gridHeight: 0,
  //viewportHeight: 0,
  //viewportMinutesBegin: 0,
  //viewportMinutesEnd: 0,

  /**
   * Количество дней в одном элементе InfiniteList.
   * Для сетки по дням.
   * @type {number}
   * @public
   */
  gridDaysItemSize: 7,

  /**
   * Количество недель в одном элементе InfiniteList.
   * Для сетки по месяцам.
   * @type {number}
   * @public
   */
  gridMonthItemSize: 5,

  /**
   * Текущая дата
   * @type {string}
   * @public
   */
  currentDate: 20170501,

  /**
   * Рабочие часы в сутках
   * @type {string}
   * @public
   */
  hoursOfDay: HOURS,

  /**
   * Объект соответствия рабочего часа с реальным положением в сетке
   * @constant {Object.<string, number>}
   */
  GRID_HOURS: GRID_HOURS,

  HOURS_LIST: HOURS_LIST,

  /**
   * Количество миллисекунд в сутках
   * @type {number}
   * @public
   * @readonly
   */
  DAYMS: DAYMS$1,

  /**
   * Рабочие интервалы в сутках
   * @type {Object}
   * @public
   * @readonly
   */
  INTERVALS: INTERVALS,

  /**
   * Выходные дни недели
   * @type {string}
   * @public
   */
  weekends: WEEKENDS,

  /**
   * Объект дней недели
   * @constant {Object.<string, number>}
   */
  WEEKENDS_SET: WEEKENDS_SET,

  /**
   * Скрывать выходные
   * @type {boolean}
   * @public
   */
  hideWeekends: false,

  /**
   * Начинать неделю с дня
   * @type {number}
   * @public
   */
  beginningOfWeek: 1,

  dateFullBegin: 0,
  dateFullEnd: 0,
  datePartBegin: 0,
  datePartEnd: 0,
  visibleDay: 0,
  visibleMonth: 0,
  visibleRateBegin: 0,
  visibleRateEnd: 0
};

var stateInfinite = {
  SAXISX: undefined,

  updated: 0,

  /**
   * Направление скролла,
   * значение увеличивается при достижении предела справа,
   * умньшается при достижении предела слева.
   * @type {number}
   * @public
   */
  scrollDirection: 0,

  /**
   * -2 - нет анимации
   * -1 - программное прерывание анимации
   * 0 - анимация выключена
   * 1 - анимация включена
   * @type {Number}
   */
  scrollAnimation: ASCROLL.DISABLE,

  /**
   * Количество предзагружаемых заранее интервалов InfiniteList слева и справа от текущего
   * @constant {number}
   * @public
   * @readonly
   */
  listRange: 1,
  scrollHeight: 0,
  scrollWidth: 0,

  /**
   * смещение скрола по оси X = -1 * listRange * scrollWidth
   * @type {number}
   * @public
   */
  scrollX: undefined,

  /**
   * смещение скрола по оси Y
   * @type {number}
   * @public
   */
  scrollY: undefined,

  /**
   * скорость скролла по X: вправо > 0; влево < 0;
   * @type {number}
   * @public
   */
  speedScrollX: 0,

  /**
   * скорость скролла по Y: вверх > 0; вниз < 0;
   * @type {number}
   * @public
   */
  speedScrollY: 0,

  /**
   * максимальное смещение при скроле влево = -1 * scrollWidth * ( listRange * 2 )
   * @type {number}
   * @private
   * @readonly
   */
  scrollOffsetLeft: 0,

  /**
   * максимальное смещение при скроле вправо
   * @constant {number}
   * @private
   * @readonly
   */
  scrollOffsetRight: 0,

  /**
   * максимальное смещение при скроле вверх = -1 * scrollHeight
   * @type {number}
   * @private
   * @readonly
   */
  scrollOffsetTop: 0,

  /**
   * максимальное смещение при скроле вниз
   * @constant {number}
   * @private
   * @readonly
   */
  scrollOffsetBottom: 0

  //stickyScrollX: false,   // ? залипающий скролл по X
  //stepScrollX: false,     // ? пошаговый скролл по X
  //freeScrollX: false,     // ? свободный скролл по X
  //freeScrollY: false,     // ? свободный скролл по Y


};

function ctorGrid() {}

function createGrid() {
  return {
    timeToRate: function timeToRate(time) {
      var hour = time / HOURMS | 0;
      var ms = time % HOURMS;
      var grid = this.current.GRID_HOURS[hour] * HOURMS + ms;
      return Math.round(1000 * 100 * grid / this.current.DAYMS) / 1000;
    },

    checkWeekend: function checkWeekend(date) {
      return getDay(date) in this.current.WEEKENDS_SET;
    },

    /**
     * @param {number} date
     * @returns {number} процент видимости даты
     */
    checkVisibleDate: function checkVisibleDate(date) {},

    isVisibleDate: function isVisibleDate(date) {
      return date >= this.current.datePartBegin && date <= this.current.datePartEnd;
    },

    isCurrentMonthDate: function isCurrentMonthDate(date) {
      return equalToMonth(this.current.visibleMonth, date);
    },

    _updateVisibleDate: function _updateVisibleDate(ref) {
      var itemSize = ref.itemSize;
      var daysInItem = ref.daysInItem;


      var ref$1 = this.current;
      var currentDate = ref$1.currentDate;
      var range = this.getVisibleRange();
      var startItem = range[0];
      var startRate = range[1];
      var endItem = range[2];
      var endRate = range[3];
      var itemRate = 100 / itemSize;
      var gridItemSize = itemSize * daysInItem;

      var startFullVisibleItem = startRate / itemRate | 0;
      var startRateRest = startRate === 100 ? 0 : startRate % itemRate;
      var startPartVisibleItem = startFullVisibleItem + (startRateRest ? 1 : 0);

      var endFullVisibleItem = endRate / itemRate | 0;
      var endRateRest = endRate === 100 ? 0 : endRate % itemRate;
      var endPartVisibleItem = endFullVisibleItem + (endRateRest ? 1 : 0);

      var daysFullBegin = gridItemSize + startItem * gridItemSize - startFullVisibleItem * daysInItem;
      var daysFullEnd = endItem * gridItemSize + endFullVisibleItem * daysInItem - 1;
      var daysPartBegin = gridItemSize + startItem * gridItemSize - startPartVisibleItem * daysInItem;
      var daysPartEnd = endItem * gridItemSize + endPartVisibleItem * daysInItem - 1;

      this.current.dateFullBegin = offsetOnDay(currentDate, daysFullBegin);
      this.current.dateFullEnd = offsetOnDay(currentDate, daysFullEnd);
      this.current.datePartBegin = offsetOnDay(currentDate, daysPartBegin);
      this.current.datePartEnd = offsetOnDay(currentDate, daysPartEnd);

      var d = (parseDate(this.current.dateFullEnd) - parseDate(this.current.dateFullBegin)) / DAYMS / 2 | 0;

      this.current.visibleDay = this.current.dateFullBegin;
      this.current.visibleMonth = getMonthDate(offsetOnDay(this.current.dateFullBegin, d)); // TODO зависит от направления скрола
      this.current.visibleRateBegin = 100 * startRateRest / itemRate | 0;
      this.current.visibleRateEnd = 100 * endRateRest / itemRate | 0;
    },

    _hoursOfDaySetter: function _hoursOfDaySetter(value) {
      var list = value.split(',').map(Number).filter(function (item) { return item >= 0 && item <= 23; });

      list.sort(function (a, b) { return a - b; });

      value = list.join(',');

      if (value !== this.current.hoursOfDay) {
        this.current.hoursOfDay = value;
        this.current.DAYMS = list.length * HOURMS;
        this.current.GRID_HOURS = toObject(list);
        this.current.INTERVALS = createIntervals(list);
        this.isChanged = true;
      }
    },

    _weekendsSetter: function _weekendsSetter(value) {
      var list = value.split(',').map(Number).filter(function (item) { return item >= 0 && item <= 6; });

      list.sort(function (a, b) { return a - b; });

      value = list.join(',');

      if (value !== this.current.weekends) {
        this.current.weekends = value;
        this.current.WEEKENDS_SET = toObject(list);
        this.updateVisibleDate();
        this.isChanged = true;
      }
    },

    _hideWeekendsSetter: function _hideWeekendsSetter(value) {
      value = Boolean(value);
      if (value !== this.current.hideWeekends) {
        this.current.hideWeekends = value;
        this.updateVisibleDate();
        this.isChanged = true;
      }
    },

    _gridDaysItemSizeSetter: function _gridDaysItemSizeSetter(value) {
      value = value | 0;
      if (value > 0 && value !== this.current.gridDaysItemSize) {
        this.current.gridDaysItemSize = value;
        this.updateVisibleDate();
        this.isChanged = true;
      }
    },

    _gridMonthItemSizeSetter: function _gridMonthItemSizeSetter(value) {
      value = value | 0;
      if (value > 0 && value !== this.current.gridMonthItemSize) {
        this.current.gridMonthItemSize = value;
        this.updateVisibleDate();
        this.isChanged = true;
      }
    },

    _currentDateSetter: function _currentDateSetter(value) {
      value = value | 0;
      if (value > 0 && value !== this.current.currentDate) {
        this.current.currentDate = value;
        this.updateVisibleDate();
        this.isChanged = true;
      }
    }
  };
}

function ctorGridDay() {}

function createGridDay() {
  return {
    gridDateOffset: function gridDateOffset(date, offset) {
      if (this.current.hideWeekends) {
        return offsetOnWorksDay(date, offset, this.current.WEEKENDS_SET);
      } else {
        return offsetOnDay(date, offset);
      }
    },

    gridDateItemOffset: function gridDateItemOffset(date, offset) {
      var dayOffset = this.current.gridDaysItemSize * offset;
      return this.gridDateOffset(date, dayOffset);
    },

    updateVisibleDate: function updateVisibleDate() {
      this._updateVisibleDate({
        itemSize: this.current.gridDaysItemSize,
        daysInItem: 1
      });
    },

    _gridDateOffsetNext: function _gridDateOffsetNext() {
      this.current.updated++;
      this.current.currentDate = this.gridDateItemOffset(this.current.currentDate, 1);
    },

    _gridDateOffsetPrev: function _gridDateOffsetPrev() {
      this.current.updated++;
      this.current.currentDate = this.gridDateItemOffset(this.current.currentDate, -1);
    }
  };
}

function ctorGridMonth() {}

function createGridMonth() {
  return {
    gridDateOffset: function gridDateOffset(date, offset) {
      return offsetOnDay(date, offset * WEEKDAYS);
    },

    gridDateItemOffset: function gridDateItemOffset(date, offset) {
      var dayOffset = this.current.gridMonthItemSize * offset;
      return this.gridDateOffset(date, dayOffset);
    },

    updateVisibleDate: function updateVisibleDate() {
      this._updateVisibleDate({
        itemSize: this.current.gridMonthItemSize,
        daysInItem: 7
      });
    },

    _gridDateOffsetNext: function _gridDateOffsetNext() {
      this.current.updated++;
      this.current.currentDate = this.gridDateItemOffset(this.current.currentDate, 1);
    },

    _gridDateOffsetPrev: function _gridDateOffsetPrev() {
      this.current.updated++;
      this.current.currentDate = this.gridDateItemOffset(this.current.currentDate, -1);
    }
  };
}

function ctorInfinite() {
  this.LIMIT_PREV = 1;
  this.LIMIT_NEXT = 2;
}

function createInfinite() {
  return {
    /**
     * Принудительное обновление через установку уникального значения updated в стейт.
     * @public
     * @return {boolean}
     */
    forceUpdated: function forceUpdated() {
      this.current.updated++;
      return true;
    },

    /**
     * Обновление позиции скрола.
     * @public
     * @param {number} deltaX
     * @param {number} deltaY
     * @return {boolean}
     */
    updateScrollByWheel: function updateScrollByWheel(deltaX, deltaY) {
      deltaX = Math.ceil(deltaX / 2);
      deltaY = Math.ceil(deltaY / 2);

      deltaX = deltaX > 0 ? Math.min(deltaX, 100) : Math.max(deltaX, -100);

      deltaY = deltaY > 0 ? Math.min(deltaY, 100) : Math.max(deltaY, -100);

      var updX = deltaX !== 0 ? this.update({
        scrollX: this.current.scrollX + deltaX
      }) : false;

      var updY = deltaY !== 0 ? this.update({
        scrollY: this.current.scrollY + deltaY
      }) : false;

      var ref = this.current;
      var scrollAnimation = ref.scrollAnimation;
      var speedScrollX = ref.speedScrollX;
      var speedScrollY = ref.speedScrollY;

      this.current.speedScrollX = updX ? deltaX : 0;
      this.current.speedScrollY = updY ? deltaY : 0;

      if (scrollAnimation >= 0) {
        this.current.scrollAnimation = updX || updY ? ASCROLL.ON : ASCROLL.OFF;
      }

      return updX || updY || scrollAnimation !== this.current.scrollAnimation || speedScrollX !== this.current.speedScrollX || speedScrollY !== this.current.speedScrollY;
    },

    _limitScroll: function _limitScroll(value, min, max) {
      return value < min ? min : value > max ? max : Math.round(value);
    },

    _limitScrollY: function _limitScrollY(value) {
      return this._limitScroll(value, this.current.scrollOffsetTop, this.current.scrollOffsetBottom);
    },

    _limitScrollX: function _limitScrollX(value) {
      return this._limitScroll(value, this.current.scrollOffsetLeft, this.current.scrollOffsetRight);
    },

    _correctLimitOffset: function _correctLimitOffset(limit, value, size) {
      switch (limit) {
        case this.LIMIT_PREV:
          return value - size;
        case this.LIMIT_NEXT:
          return value + size;
        default:
          return value;
      }
    },

    _checkLimitOffset: function _checkLimitOffset(scroll, offsetPrev, offsetNext) {
      var scrollOffsetCenter = (offsetPrev + offsetNext) / 2;
      var scrollOffsetWidth = offsetPrev > offsetNext ? offsetPrev - offsetNext : offsetNext - offsetPrev;
      var centerOffsetWidth = scrollOffsetWidth / 2;
      var sign = scroll > scrollOffsetCenter ? 1 : -1;
      var scroll2CenterWidth = scroll > scrollOffsetCenter ? scroll - scrollOffsetCenter : scrollOffsetCenter - scroll;
      var rate = centerOffsetWidth ? sign * scroll2CenterWidth * 100 / centerOffsetWidth : 0;
      var rateCompare = 100 / this.current.listRange;

      if (rate <= -rateCompare) {
        return this.LIMIT_NEXT;
      } else if (rate >= rateCompare) {
        return this.LIMIT_PREV;
      }

      return 0;
    },

    _getVisibleRange: function _getVisibleRange(scroll, size) {
      var precision = 10000;
      var listRange = this.current.listRange;
      var start = Math.abs(scroll / size);
      var startRate = precision - (start % 1 * precision | 0);
      var startItem = (start | 0) - listRange;

      return [startItem, startRate / 100, startItem + 1, (precision - startRate) / 100];
    }
  };
}

function ctorInfiniteX() {
  this.current.SAXISX = true;
  this.current.scrollY = 0;
}

function createInfiniteX() {
  return {
    isVisibleOffset: function isVisibleOffset(offset) {
      var ref = this.current;
      var scrollX = ref.scrollX;
      var scrollWidth = ref.scrollWidth;
      var listRange = ref.listRange;
      var speedScrollX = ref.speedScrollX;
      var min = this._getScrollXByOffset(offset);
      var max = min - scrollWidth;
      var maxOffset = scrollX / listRange;
      var minOffset = scrollX - scrollWidth * listRange;

      return scrollX !== undefined && !Boolean(max > maxOffset || max === maxOffset && speedScrollX <= 0 || min < minOffset || min === minOffset && speedScrollX >= 0);
    },

    getVisibleRange: function getVisibleRange() {
      return this._getVisibleRange(this.current.scrollX, this.current.scrollWidth);
    },

    _getScrollXByOffset: function _getScrollXByOffset(offset) {
      return -1 * (offset + 1) * this.current.listRange * this.current.scrollWidth;
    },

    _correctScrollX: function _correctScrollX() {
      var limitOffset = this._checkLimitOffset(this.current.scrollX, this.current.scrollOffsetLeft, this.current.scrollOffsetRight);

      if (!limitOffset) {
        return;
      }

      if (this.current.scrollAnimation === ASCROLL.ON || this.current.scrollAnimation === ASCROLL.OFF) {
        this.current.scrollAnimation = ASCROLL.STOP;
      }

      this.current.scrollDirection = this._correctLimitOffset(limitOffset, this.current.scrollDirection, 1);

      this.current.scrollX = this._limitScrollX(this._correctLimitOffset(limitOffset, this.current.scrollX, this.current.scrollWidth));

      switch (limitOffset) {
        case this.LIMIT_PREV:
          this._gridDateOffsetPrev();
          break;
        case this.LIMIT_NEXT:
          this._gridDateOffsetNext();
          break;
      }
    },

    _scrollHeightSetter: function _scrollHeightSetter(value) {
      var scrollHeight = this.current.scrollHeight;

      this.current.scrollHeight = value;
      this.current.scrollOffsetTop = -1 * value;

      this.current.scrollY = this._limitScrollY(scrollHeight > 0 ? this.current.scrollY * value / scrollHeight : 0);

      this.isChanged = true;
    },

    _scrollWidthSetter: function _scrollWidthSetter(value) {
      var scrollWidth = this.current.scrollWidth;

      this.current.scrollWidth = value;
      // -2 потому что listRange слева и справа
      this.current.scrollOffsetLeft = -2 * this.current.listRange * value;

      this.current.scrollX = this._limitScrollX(this.current.scrollX === undefined ? this._getScrollXByOffset(0) : scrollWidth > 0 ? this.current.scrollX * value / scrollWidth : 0);

      this._correctScrollX();
      this.updateVisibleDate();
      this.isChanged = true;
    },

    _scrollXSetter: function _scrollXSetter(value) {
      value = this._limitScrollX(value);
      if (value !== this.current.scrollX) {
        this.current.scrollX = value;
        this._correctScrollX();
        this.updateVisibleDate();
        this.isChanged = true;
      }
    },

    _scrollYSetter: function _scrollYSetter(value) {
      value = this._limitScrollY(value);
      if (value !== this.current.scrollY) {
        this.current.scrollY = value;
        this.isChanged = true;
      }
    }
  };
}

function ctorInfiniteY() {
  this.current.SAXISX = false;
  this.current.scrollX = 0;
}

function createInfiniteY() {
  return {
    isVisibleOffset: function isVisibleOffset(offset) {
      var ref = this.current;
      var scrollY = ref.scrollY;
      var scrollHeight = ref.scrollHeight;
      var listRange = ref.listRange;
      var speedScrollY = ref.speedScrollY;
      var min = this._getScrollYByOffset(offset);
      var max = min - scrollHeight;
      var maxOffset = scrollY / listRange;
      var minOffset = scrollY - scrollHeight * listRange;

      return scrollY !== undefined && !Boolean(max > maxOffset || max === maxOffset && speedScrollY <= 0 || min < minOffset || min === minOffset && speedScrollY >= 0);
    },

    getVisibleRange: function getVisibleRange() {
      return this._getVisibleRange(this.current.scrollY, this.current.scrollHeight);
    },

    _getScrollYByOffset: function _getScrollYByOffset(offset) {
      return -1 * (offset + 1) * this.current.listRange * this.current.scrollHeight;
    },

    _correctScrollY: function _correctScrollY() {
      var limitOffset = this._checkLimitOffset(this.current.scrollY, this.current.scrollOffsetTop, this.current.scrollOffsetBottom);

      if (!limitOffset) {
        return;
      }

      if (this.current.scrollAnimation === ASCROLL.ON || this.current.scrollAnimation === ASCROLL.OFF) {
        this.current.scrollAnimation = ASCROLL.STOP;
      }

      this.current.scrollDirection = this._correctLimitOffset(limitOffset, this.current.scrollDirection, 1);

      this.current.scrollY = this._limitScrollY(this._correctLimitOffset(limitOffset, this.current.scrollY, this.current.scrollHeight));

      switch (limitOffset) {
        case this.LIMIT_PREV:
          this._gridDateOffsetPrev();
          break;
        case this.LIMIT_NEXT:
          this._gridDateOffsetNext();
          break;
      }
    },

    _scrollHeightSetter: function _scrollHeightSetter(value) {
      var scrollHeight = this.current.scrollHeight;

      this.current.scrollHeight = value;
      // -2 потому что listRange сверху и снизу
      this.current.scrollOffsetTop = -2 * this.current.listRange * value;

      this.current.scrollY = this._limitScrollY(this.current.scrollY === undefined ? this._getScrollYByOffset(0) : scrollHeight > 0 ? this.current.scrollY * value / scrollHeight : 0);

      this._correctScrollY();
      this.updateVisibleDate();
      this.isChanged = true;
    },

    _scrollWidthSetter: function _scrollWidthSetter(value) {
      var scrollWidth = this.current.scrollWidth;

      this.current.scrollWidth = value;
      this.current.scrollOffsetLeft = -1 * value;

      this.current.scrollX = this._limitScrollX(scrollWidth > 0 ? this.current.scrollX * value / scrollWidth : 0);

      this.isChanged = true;
    },

    _scrollXSetter: function _scrollXSetter(value) {
      value = this._limitScrollX(value);
      if (value !== this.current.scrollX) {
        this.current.scrollX = value;
        this.isChanged = true;
      }
    },

    _scrollYSetter: function _scrollYSetter(value) {
      value = this._limitScrollY(value);
      if (value !== this.current.scrollY) {
        this.current.scrollY = value;
        this._correctScrollY();
        this.updateVisibleDate();
        this.isChanged = true;
      }
    },

    _listRangeSetter: function _listRangeSetter(value) {
      value = value | 0;
      if (value > 0 && value !== this.current.listRange) {
        this.current.listRange = value;
        this.isChanged = true;
      }
    }
  };
}

var _dec$1;
var _class$3;
var _dec2$1;
var _class2$1;

var defaultState = _extends({}, stateGrid, stateInfinite);

var GridDayStrategy = (_dec$1 = mixin([createGrid(), createGridDay(), createInfinite(), createInfiniteX()]), _dec$1(_class$3 = (function (StoreStrategy$$1) {
  function GridDayStrategy(data) {
    if ( data === void 0 ) data = defaultState;

    StoreStrategy$$1.call(this, data);
    ctorGrid.call(this);
    ctorGridDay.call(this);
    ctorInfinite.call(this);
    ctorInfiniteX.call(this);
  }

  if ( StoreStrategy$$1 ) GridDayStrategy.__proto__ = StoreStrategy$$1;
  GridDayStrategy.prototype = Object.create( StoreStrategy$$1 && StoreStrategy$$1.prototype );
  GridDayStrategy.prototype.constructor = GridDayStrategy;

  return GridDayStrategy;
}(StoreStrategy))) || _class$3);

var GridMonthStrategy = (_dec2$1 = mixin([createGrid(), createGridMonth(), createInfinite(), createInfiniteY()]), _dec2$1(_class2$1 = (function (StoreStrategy$$1) {
  function GridMonthStrategy(data) {
    if ( data === void 0 ) data = defaultState;

    StoreStrategy$$1.call(this, data);
    ctorGrid.call(this);
    ctorGridMonth.call(this);
    ctorInfinite.call(this);
    ctorInfiniteY.call(this);
  }

  if ( StoreStrategy$$1 ) GridMonthStrategy.__proto__ = StoreStrategy$$1;
  GridMonthStrategy.prototype = Object.create( StoreStrategy$$1 && StoreStrategy$$1.prototype );
  GridMonthStrategy.prototype.constructor = GridMonthStrategy;

  return GridMonthStrategy;
}(StoreStrategy))) || _class2$1);

var CommonStore = (function (Store$$1) {
  function CommonStore(strategy) {
    Store$$1.call(this, strategy || new GridDayStrategy());
  }

  if ( Store$$1 ) CommonStore.__proto__ = Store$$1;
  CommonStore.prototype = Object.create( Store$$1 && Store$$1.prototype );
  CommonStore.prototype.constructor = CommonStore;

  CommonStore.prototype.switchStrategyGridDay = function switchStrategyGridDay () {
    var state = _extends({}, this.getState());
    state.scrollY = undefined;
    state.scrollX = undefined;
    this.setStrategy(new GridDayStrategy(state));
  };

  CommonStore.prototype.switchStrategyGridMonth = function switchStrategyGridMonth () {
    var state = _extends({}, this.getState());
    state.scrollY = undefined;
    state.scrollX = undefined;
    this.setStrategy(new GridMonthStrategy(state));
  };

  // -------------------------------------------------------------
  CommonStore.prototype.gridDateOffset = function gridDateOffset (date, offset) {
    return this._strategy.gridDateOffset(date, offset);
  };

  CommonStore.prototype.gridDateItemOffset = function gridDateItemOffset (date, offset) {
    return this._strategy.gridDateItemOffset(date, offset);
  };

  CommonStore.prototype.timeToRate = function timeToRate (time) {
    return this._strategy.timeToRate(time);
  };

  CommonStore.prototype.checkWeekend = function checkWeekend (date) {
    return this._strategy.checkWeekend(date);
  };
  // -------------------------------------------------------------


  // -------------------------------------------------------------
  CommonStore.prototype.forceUpdated = function forceUpdated () {
    if (this._strategy.forceUpdated()) {
      this.emitChange();
    }
  };

  CommonStore.prototype.updateScrollByWheel = function updateScrollByWheel (deltaX, deltaY) {
    if (this._strategy.updateScrollByWheel(deltaX, deltaY)) {
      this.emitChange();
    }
  };

  CommonStore.prototype.isVisibleOffset = function isVisibleOffset (offset) {
    return this._strategy.isVisibleOffset(offset);
  };

  CommonStore.prototype.getVisibleRange = function getVisibleRange () {
    return this._strategy.getVisibleRange();
  };
  // -------------------------------------------------------------

  // -------------------------------------------------------------
  /**
   * @param {number} date
   * @returns {number} процент видимости даты
   */
  CommonStore.prototype.checkVisibleDate = function checkVisibleDate (date) {
    return this._strategy.checkVisibleDate(date);
  };

  CommonStore.prototype.isVisibleDate = function isVisibleDate (date) {
    return this._strategy.isVisibleDate(date);
  };

  CommonStore.prototype.isCurrentMonthDate = function isCurrentMonthDate (date) {
    return this._strategy.isCurrentMonthDate(date);
  };

  return CommonStore;
}(Store));

var PropTypes = React.PropTypes;

function context(component) {
  component.contextTypes = {
    datetime: PropTypes.instanceOf(Datetime),
    events: PropTypes.instanceOf(Events),
    store: PropTypes.instanceOf(CommonStore)
  };
}

function stateful(component) {
  component.prototype.shouldComponentUpdate = shouldComponentUpdate;
  component.prototype.componentDidUpdate = componentDidUpdate;
  component.prototype.transformState = transformState;
  component.prototype.updateState = updateState;
}

function shouldComponentUpdate() {
  return false;
}

function componentDidUpdate() {
  this._lockSetState = false;

  if (this._shouldUpdateState) {
    this.updateState();
  }
}

function transformState() /* props, context */{
  return {};
}

function updateState(newProps) {
  if ( newProps === void 0 ) newProps = this.props;

  if (this._lockSetState) {
    this._shouldUpdateState = true;
    return;
  }

  this._shouldUpdateState = false;

  var newState = this.transformState(newProps, this.context);

  if (this.shouldComponentUpdate(newProps, newState)) {
    this._lockSetState = true;
    this.setState(newState);
  } else {
    this._lockSetState = false;
  }
}

function mutable(watched) {
  return function (component) {
    var proto = component.prototype;
    var didMount = proto.componentDidMount;
    var willUnmount = proto.componentWillUnmount;

    proto.componentDidMount = function () {
      didMount && didMount.call(this);
      this.context[watched].addChangeListener(this.updateState, this);
    };

    proto.componentWillUnmount = function () {
      willUnmount && willUnmount.call(this);
      this.context[watched].removeChangeListener(this.updateState, this);
    };
  };
}

var _class;
var _dec;
var _class2;
var _dec2;
var _class3;

var Component = context(_class = stateful(_class = (function (superclass) {
  function Component(props, context$$1) {
    superclass.call(this, props, context$$1);
    this.state = this.transformState(props, context$$1);
  }

  if ( superclass ) Component.__proto__ = superclass;
  Component.prototype = Object.create( superclass && superclass.prototype );
  Component.prototype.constructor = Component;

  return Component;
}(React.Component))) || _class) || _class;

var StoreComponent = (_dec = mutable('store'), context(_class2 = stateful(_class2 = _dec(_class2 = (function (superclass) {
  function StoreComponent(props, context$$1) {
    superclass.call(this, props, context$$1);
    this.state = this.transformState(props, context$$1);
  }

  if ( superclass ) StoreComponent.__proto__ = superclass;
  StoreComponent.prototype = Object.create( superclass && superclass.prototype );
  StoreComponent.prototype.constructor = StoreComponent;

  return StoreComponent;
}(React.Component))) || _class2) || _class2) || _class2);

var EventsComponent = (_dec2 = mutable('events'), context(_class3 = stateful(_class3 = _dec2(_class3 = (function (superclass) {
  function EventsComponent(props, context$$1) {
    superclass.call(this, props, context$$1);
    this.state = this.transformState(props, context$$1);
  }

  if ( superclass ) EventsComponent.__proto__ = superclass;
  EventsComponent.prototype = Object.create( superclass && superclass.prototype );
  EventsComponent.prototype.constructor = EventsComponent;

  /**
   * @final
   */
  EventsComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {
    this.updateState(nextProps);

    if (this.props.date !== nextProps.date) {
      this.upload(this.getInterval(nextProps));
    }
  };

  /**
   * @final
   */
  EventsComponent.prototype.componentDidMount = function componentDidMount () {
    this.upload();
  };

  /**
   * @final
   */
  EventsComponent.prototype.componentWillUnmount = function componentWillUnmount () {
    this.cancelUpload();
  };

  /**
   * @abstract
   */
  EventsComponent.prototype.getInterval = function getInterval () {
    return [];
  };

  /**
   * @final
   */
  EventsComponent.prototype.upload = function upload (interval) {
    if ( interval === void 0 ) interval = this.getInterval();

    this.cancelUpload();
    this._upload = this.context.events.uploadByInterval(interval);
  };

  /**
   * @final
   */
  EventsComponent.prototype.cancelUpload = function cancelUpload () {
    if (this._upload) {
      this._upload.cancel();
      this._upload = null;
    }
  };

  return EventsComponent;
}(React.Component))) || _class3) || _class3) || _class3);

var ONSTOP = Symbol('wheel-stop');
var ONSTOPSUCCESS = Symbol('wheel-stop-success');
var ONUPDATE = Symbol('wheel-update');
var ONWHEEL = Symbol('wheel-callback');
var STIMER = Symbol('wheel-stop-timer');
var STIMERSUCCESS = Symbol('wheel-stop-timer-success');
var WHEELSTART = Symbol('wheel-start');
var WHEELX = Symbol('wheel-delta-x');
var WHEELY = Symbol('wheel-delta-y');
var WTIMER = Symbol('wheel-timer');

var passiveSupported = false;
try {
  var options = Object.defineProperty({}, 'passive', {
    get: function () {
      passiveSupported = true;
    }
  });

  context$1.addEventListener('test', null, options);
} catch (err) {}

var doc = context$1.document;
var wheelEventName = doc ? 'onwheel' in doc.createElement('div') ? 'wheel' : doc.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll' : 'wheel';

var wheelEventOptions = passiveSupported ? { passive: true } : false;

var onWheel = wrapWheelCallback(function _onWheel(event) {
  if (!passiveSupported) {
    event.preventDefault();
  }

  var timer = this[WTIMER];

  if (!this[WHEELSTART]) {
    this[WHEELSTART] = true;
    this.handleWheelStart && this.handleWheelStart();
  }

  this[WHEELX] = event.deltaX + (timer ? this[WHEELX] : 0);
  this[WHEELY] = event.deltaY + (timer ? this[WHEELY] : 0);

  if (!timer) {
    //this[ WTIMER ] = context.requestAnimationFrame(() => {
    this[WTIMER] = context$1.requestAnimationFrame(this[ONUPDATE]);
    //});
  }
});

var onWheelUpdate = function _onWheelUpdate() {
  this.handleWheel && this.handleWheel(this[WHEELX], this[WHEELY]);
  this[WTIMER] = 0;
  this[STIMER] = context$1.requestAnimationFrame(this[ONSTOP]);
};

var onWheelStop = function _onWheelStop() {
  if (this[STIMERSUCCESS]) {
    context$1.clearTimeout(this[STIMERSUCCESS]);
    this[STIMERSUCCESS] = 0;
  }

  if (!this[WTIMER]) {
    this[STIMERSUCCESS] = context$1.setTimeout(this[ONSTOPSUCCESS], 150);
  }
};

var onWheelStopSuccess = function _onWheelStopSuccess() {
  this[STIMERSUCCESS] = 0;
  if (!this[WTIMER]) {
    this[WHEELSTART] = false;
    this.handleWheelStop && this.handleWheelStop();
  }
};

function wheel(component) {
  var proto = component.prototype;
  var didMount = proto.componentDidMount;
  var willUnmount = proto.componentWillUnmount;

  proto.componentDidMount = function () {
    didMount && didMount.call(this);

    this[ONWHEEL] = onWheel.bind(this);
    this[ONUPDATE] = onWheelUpdate.bind(this);
    this[ONSTOP] = onWheelStop.bind(this);
    this[ONSTOPSUCCESS] = onWheelStopSuccess.bind(this);

    this._rootNode.addEventListener(wheelEventName, this[ONWHEEL], wheelEventOptions);
  };

  proto.componentWillUnmount = function () {
    willUnmount && willUnmount.call(this);

    this[WHEELSTART] = false;

    this._rootNode.removeEventListener(wheelEventName, this[ONWHEEL], wheelEventOptions);

    if (this[WTIMER]) {
      context$1.cancelAnimationFrame(this[WTIMER]);
      this[WTIMER] = 0;
    }

    if (this[STIMER]) {
      context$1.cancelAnimationFrame(this[STIMER]);
      this[STIMER] = 0;
    }

    if (this[STIMERSUCCESS]) {
      context$1.clearTimeout(this[STIMERSUCCESS]);
      this[STIMERSUCCESS] = 0;
    }
  };
}

function wrapWheelCallback(callback) {
  if (wheelEventName === 'wheel') {
    return callback;
  }

  return function (originalEvent) {
    if (!originalEvent) {
      originalEvent = context$1.event;
    }

    var event = {
      originalEvent: originalEvent,
      target: originalEvent.target || originalEvent.srcElement,
      type: 'wheel',
      deltaMode: 1,
      deltaX: 0,
      deltaY: 0,
      deltaZ: 0,
      clientX: originalEvent.clientX,
      clientY: originalEvent.clientY,
      preventDefault: function () {
        if (originalEvent.preventDefault) {
          originalEvent.preventDefault();
        } else {
          originalEvent.returnValue = false;
        }
      },
      stopPropagation: function () {
        if (originalEvent.stopPropagation) {
          originalEvent.stopPropagation();
        }
      },
      stopImmediatePropagation: function () {
        if (originalEvent.stopImmediatePropagation) {
          originalEvent.stopImmediatePropagation();
        }
      }
    };

    if (wheelEventName === 'mousewheel') {
      event.deltaY = -1 / 40 * originalEvent.wheelDelta;

      if (originalEvent.wheelDeltaX) {
        event.deltaX = -1 / 40 * originalEvent.wheelDeltaX;
      }
    } else {
      event.deltaY = originalEvent.detail;
    }

    return callback(event);
  };
}

var styles = __$injectStyle("698411118");

/**
 *
 */

var DayHeader = (function (Component$$1) {
  function DayHeader () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) DayHeader.__proto__ = Component$$1;
  DayHeader.prototype = Object.create( Component$$1 && Component$$1.prototype );
  DayHeader.prototype.constructor = DayHeader;

  DayHeader.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps) {
    return this.props.date !== nextProps.date || this.props.isWeekend !== nextProps.isWeekend;
  };

  DayHeader.prototype.render = function render () {
    var obj;

    var datetime = this.context.datetime;
    var ref = this.props;
    var date = ref.date;
    var isWeekend = ref.isWeekend;
    var classes = classnames(( obj = {}, obj[styles.DayHeader] = true, obj[styles.DayHeader__weekend] = isWeekend, obj ));

    return h(
      'div',
      { className: classes },
      h(
        'div',
        { className: styles.DayHeader_Title },
        datetime.gridDaysDayTitle(date)
      )
    );
  };

  return DayHeader;
}(Component));
DayHeader.defaultProps = {
  isWeekend: false
};

var styles$1 = __$injectStyle("3231277828");

var InfiniteListItem = (function (Component$$1) {
  function InfiniteListItem () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) InfiniteListItem.__proto__ = Component$$1;
  InfiniteListItem.prototype = Object.create( Component$$1 && Component$$1.prototype );
  InfiniteListItem.prototype.constructor = InfiniteListItem;

  InfiniteListItem.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps) {
    var props = this.props;
    return props.isVisible !== nextProps.isVisible || props.offset !== nextProps.offset || props.updated !== nextProps.updated;
  };

  InfiniteListItem.prototype.render = function render () {
    var obj;

    var ref = this.props;
    var getItemElement = ref.getItemElement;
    var isVisible = ref.isVisible;
    var offset = ref.offset;
    var saxisx = ref.saxisx;

    var classes = classnames(( obj = {}, obj[styles$1.InfiniteListItem] = true, obj[styles$1.InfiniteListItem__axisX] = saxisx, obj ));

    return h(
      'div',
      { className: classes },
      isVisible ? getItemElement(offset) : null
    );
  };

  return InfiniteListItem;
}(Component));
InfiniteListItem.defaultProps = {
  getItemElement: function () { return null; },
  isVisible: false,
  offset: 0,
  saxisx: 0,
  updated: 0
};

var styles$2 = __$injectStyle("125746737");

var InfiniteList = (function (StoreComponent$$1) {
  function InfiniteList () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) InfiniteList.__proto__ = StoreComponent$$1;
  InfiniteList.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  InfiniteList.prototype.constructor = InfiniteList;

  InfiniteList.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var listRange = ref.listRange;
    var SAXISX = ref.SAXISX;
    var scrollAnimation = ref.scrollAnimation;
    var scrollDirection = ref.scrollDirection;
    var scrollX = ref.scrollX;
    var scrollY = ref.scrollY;
    var speedScrollX = ref.speedScrollX;
    var speedScrollY = ref.speedScrollY;
    var updated = ref.updated;

    return {
      listRange: listRange,
      SAXISX: SAXISX,
      scrollAnimation: scrollAnimation,
      scrollDirection: scrollDirection,
      scrollX: scrollX,
      scrollY: scrollY,
      speedScrollX: speedScrollX,
      speedScrollY: speedScrollY,
      updated: updated
    };
  };

  InfiniteList.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    var state = this.state;

    return state.updated !== nextState.updated || state.listRange !== nextState.listRange || state.scrollAnimation !== nextState.scrollAnimation || state.SAXISX && (state.scrollX !== nextState.scrollX || state.speedScrollX !== nextState.speedScrollX) || !state.SAXISX && (state.scrollY !== nextState.scrollY || state.speedScrollY !== nextState.speedScrollY);
  };

  InfiniteList.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
    StoreComponent$$1.prototype.componentDidUpdate.call(this, prevProps, prevState);

    if (this.state.scrollAnimation === ASCROLL.STOP) {
      this.context.store.update({
        scrollAnimation: ASCROLL.OFF
      });
    }
  };

  InfiniteList.prototype.getItems = function getItems () {
    var this$1 = this;

    var store = this.context.store;
    var ref = this.state;
    var listRange = ref.listRange;
    var updated = ref.updated;
    var SAXISX = ref.SAXISX;
    var items = [];

    var offset = -listRange;

    while (offset <= listRange) {
      var isVisible = store.isVisibleOffset(offset);

      items.push(h(InfiniteListItem, {
        key: offset,
        isVisible: isVisible,
        offset: offset,
        saxisx: SAXISX,
        updated: updated,
        getItemElement: this$1.props.getItemElement }));

      offset++;
    }

    return items;
  };

  InfiniteList.prototype.render = function render () {
    var obj;

    var ref = this.state;
    var SAXISX = ref.SAXISX;
    var scrollAnimation = ref.scrollAnimation;
    var scrollX = ref.scrollX;
    var scrollY = ref.scrollY;
    var speedScrollX = ref.speedScrollX;
    var speedScrollY = ref.speedScrollY;

    var style = SAXISX ? ("transform: translateX(" + scrollX + "px);") : ("transform: translateY(" + scrollY + "px);");

    var classes = classnames(( obj = {}, obj[styles$2.InfiniteList_Content] = true, obj[styles$2.InfiniteList_Content__animation] = scrollAnimation === ASCROLL.ON, obj[styles$2.InfiniteList_Content__scrolling] = SAXISX ? speedScrollX !== 0 : speedScrollY !== 0, obj ));

    return h(
      'div',
      { className: styles$2.InfiniteList },
      h(
        'div',
        { className: classes, style: style },
        this.getItems()
      )
    );
  };

  return InfiniteList;
}(StoreComponent));
InfiniteList.defaultProps = {
  getItemElement: function () { return null; }
};

var styles$3 = __$injectStyle("1506717487");

var GridDaysItem = (function (StoreComponent$$1) {
  function GridDaysItem () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) GridDaysItem.__proto__ = StoreComponent$$1;
  GridDaysItem.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  GridDaysItem.prototype.constructor = GridDaysItem;

  GridDaysItem.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var hideWeekends = ref.hideWeekends;
    var hoursOfDay = ref.hoursOfDay;
    var weekends = ref.weekends;

    return {
      hideWeekends: hideWeekends,
      hoursOfDay: hoursOfDay,
      weekends: weekends
    };
  };

  GridDaysItem.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    var state = this.state;
    var props = this.props;

    return props.date !== nextProps.date || props.itemSize !== nextProps.itemSize || state.hideWeekends !== nextState.hideWeekends || state.hoursOfDay !== nextState.hoursOfDay || state.weekends !== nextState.weekends;
  };

  GridDaysItem.prototype.getItems = function getItems () {
    var store = this.context.store;
    var ref = this.props;
    var date = ref.date;
    var itemSize = ref.itemSize;
    var ItemComponent = ref.ItemComponent;
    var ref$1 = this.state;
    var hoursOfDay = ref$1.hoursOfDay;
    var hideWeekends = ref$1.hideWeekends;
    var items = [];

    var idx = 0;
    var idxLocal = 0; // local index minimizes redraw

    while (idx < itemSize) {
      var itemDate = store.gridDateOffset(date, idx);
      var isWeekend = store.checkWeekend(itemDate);

      if (!isWeekend || !hideWeekends) {
        items.push(h(ItemComponent, {
          key: idxLocal,
          date: itemDate,
          hoursOfDay: hoursOfDay,
          isWeekend: isWeekend }));

        idxLocal++;
      }

      idx++;
    }

    return items;
  };

  GridDaysItem.prototype.render = function render () {
    return h(
      'div',
      { className: styles$3.GridDaysItem },
      this.getItems()
    );
  };

  return GridDaysItem;
}(StoreComponent));
GridDaysItem.defaultProps = {
  date: 0,
  itemSize: 0
};

var styles$4 = __$injectStyle("4080515877");

var GridDaysHeader = (function (StoreComponent$$1) {
  function GridDaysHeader(props, context) {
    StoreComponent$$1.call(this, props, context);
    this.getItemElement = this.getItemElement.bind(this);
  }

  if ( StoreComponent$$1 ) GridDaysHeader.__proto__ = StoreComponent$$1;
  GridDaysHeader.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  GridDaysHeader.prototype.constructor = GridDaysHeader;

  GridDaysHeader.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var gridDaysItemSize = ref.gridDaysItemSize;
    var currentDate = ref.currentDate;
    return { gridDaysItemSize: gridDaysItemSize, currentDate: currentDate };
  };

  GridDaysHeader.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.state.gridDaysItemSize !== nextState.gridDaysItemSize || this.state.currentDate !== nextState.currentDate;
  };

  GridDaysHeader.prototype.getItemElement = function getItemElement (offset) {
    var ref = this.state;
    var currentDate = ref.currentDate;
    var gridDaysItemSize = ref.gridDaysItemSize;

    var date = this.context.store.gridDateItemOffset(currentDate, offset);

    return h(GridDaysItem, {
      date: date,
      ItemComponent: DayHeader,
      itemSize: gridDaysItemSize });
  };

  GridDaysHeader.prototype.render = function render () {
    return h(
      'div',
      { className: styles$4.GridDaysHeader },
      h(
        'div',
        { className: styles$4.GridDaysHeader_Content },
        h(InfiniteList, {
          getItemElement: this.getItemElement })
      )
    );
  };

  return GridDaysHeader;
}(StoreComponent));

var ONRESIZE = Symbol('resize-callback');
var RTIMER = Symbol('resize-timer');

function resize(component) {
  var proto = component.prototype;
  var didMount = proto.componentDidMount;
  var willUnmount = proto.componentWillUnmount;

  proto.componentDidMount = function () {
    didMount && didMount.call(this);
    this[ONRESIZE] = this.handleResize.bind(this);

    var that = this;
    this[RTIMER] = context$1.requestAnimationFrame(function _resizeMount() {
      that[ONRESIZE]();
      context$1.addEventListener('resize', that[ONRESIZE], false);
    });
  };

  proto.componentWillUnmount = function () {
    willUnmount && willUnmount.call(this);
    context$1.removeEventListener('resize', this[ONRESIZE], false);

    if (this[RTIMER]) {
      context$1.cancelAnimationFrame(this[RTIMER]);
      this[RTIMER] = 0;
    }
  };
}

var styles$5 = __$injectStyle("3588246877");

var DayEvent = (function (Component$$1) {
  function DayEvent () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) DayEvent.__proto__ = Component$$1;
  DayEvent.prototype = Object.create( Component$$1 && Component$$1.prototype );
  DayEvent.prototype.constructor = DayEvent;

  DayEvent.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps) {
    return this.props.top !== nextProps.top || this.props.bottom !== nextProps.bottom || this.props.left !== nextProps.left || this.props.right !== nextProps.right;
  };

  DayEvent.prototype.render = function render () {
    var ref = this.props;
    var event = ref.event;
    var top = ref.top;
    var bottom = ref.bottom;
    var left = ref.left;
    var right = ref.right;
    var fontSize = 0.9;
    var style = "\n      font-size: " + fontSize + "em;\n      left: " + left + "%;\n      right: " + right + "%;\n      top: " + top + "%;\n      bottom: " + bottom + "%;";

    return h(
      'div',
      { className: styles$5.DayEvent, style: style },
      event.title
    );
  };

  return DayEvent;
}(Component));
DayEvent.defaultProps = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
};

var styles$6 = __$injectStyle("818803677");

var DayEventFolded = (function (Component$$1) {
  function DayEventFolded () {
    Component$$1.apply(this, arguments);
  }

  if ( Component$$1 ) DayEventFolded.__proto__ = Component$$1;
  DayEventFolded.prototype = Object.create( Component$$1 && Component$$1.prototype );
  DayEventFolded.prototype.constructor = DayEventFolded;

  DayEventFolded.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps) {
    return this.props.top !== nextProps.top;
  };

  DayEventFolded.prototype.render = function render () {
    return h('div', {
      style: ("top: " + (this.props.top) + "%;"),
      className: styles$6.DayEventFolded });
  };

  return DayEventFolded;
}(Component));
DayEventFolded.defaultProps = {
  events: [],
  top: 0
};

var styles$7 = __$injectStyle("1033337454");

var DayEvents = (function (EventsComponent$$1) {
  function DayEvents () {
    EventsComponent$$1.apply(this, arguments);
  }

  if ( EventsComponent$$1 ) DayEvents.__proto__ = EventsComponent$$1;
  DayEvents.prototype = Object.create( EventsComponent$$1 && EventsComponent$$1.prototype );
  DayEvents.prototype.constructor = DayEvents;

  DayEvents.prototype.transformState = function transformState (props, context) {
    var interval = this.getInterval(props);
    var eventsIterator = context.events.getByInterval(interval);
    var ref = context.store.getState();
    var INTERVALS = ref.INTERVALS;

    return {
      eventsIterator: eventsIterator,
      INTERVALS: INTERVALS
    };
  };

  DayEvents.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.props.date !== nextProps.date || this.props.hoursOfDay !== nextProps.hoursOfDay || this.state.eventsIterator !== nextState.eventsIterator;
  };

  DayEvents.prototype.getInterval = function getInterval (props) {
    if ( props === void 0 ) props = this.props;

    return [props.date];
  };

  DayEvents.prototype.getItems = function getItems () {
    var items = [];
    var events = this.state.eventsIterator;

    var store = this.context.store;
    var date = this.props.date;
    var INTERVALS = this.state.INTERVALS;
    var eventsFolded = {};
    var eventsColumn = {};
    var columns = [];
    var columnsTimeMax = 0;

    var ilen = INTERVALS.length;

    var result;
    while ((result = events.next()) && !result.done) {
      var event = result.value;
      var eventId = event.getId();
      var timeEnd = event.get('timeEnd');
      var timeBegin = event.get('timeBegin');

      for (var j = 0; j < ilen; j++) {
        var interval = INTERVALS[j];
        var intervalBegin = interval[0];
        var intervalEnd = interval[1];
        var intervalFolded = interval[2];
        var intervalKey = date + "-" + intervalBegin + "-" + intervalEnd;

        if (timeEnd <= intervalBegin || timeBegin >= intervalEnd) {
          continue;
        }

        if (intervalFolded) {
          if (intervalKey in eventsFolded) {
            eventsFolded[intervalKey].push(event);
          } else {
            eventsFolded[intervalKey] = [event];

            items.push({
              folded: true,
              key: intervalKey,
              top: store.timeToRate(intervalBegin - 1),
              events: eventsFolded[intervalKey]
            });
          }
        } else {
          if (timeBegin > columnsTimeMax) {
            columns = [];
          }

          if (timeEnd > columnsTimeMax) {
            columnsTimeMax = timeEnd;
          }

          var column = eventId in eventsColumn ? eventsColumn[eventId] : getColumn(timeBegin, columns);

          columns[column] = timeEnd;
          eventsColumn[eventId] = column;

          items.push({
            key: (intervalKey + "-" + eventId),
            top: store.timeToRate(Math.max(timeBegin, intervalBegin)),
            bottom: 100 - store.timeToRate(Math.min(timeEnd, intervalEnd - 1)),
            column: column,
            columns: columns,
            event: event
          });
        }
      }
    }

    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];

      if (item.folded) {
        items[i] = h(DayEventFolded, {
          key: item.key,
          top: item.top,
          events: item.events });
      } else {
        var clen = item.columns.length;
        var left = 100 - 100 * (clen - item.column) / clen;
        var right = 100 - (left + 100 / clen);

        items[i] = h(DayEvent, {
          key: item.key,
          left: left,
          right: right,
          top: item.top,
          bottom: item.bottom,
          event: item.event });
      }
    }

    return items;
  };

  DayEvents.prototype.render = function render () {
    return h(
      'div',
      { className: styles$7.DayEvents },
      this.getItems()
    );
  };

  return DayEvents;
}(EventsComponent));

var styles$8 = __$injectStyle("3216744561");

var Day = (function (StoreComponent$$1) {
  function Day () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) Day.__proto__ = StoreComponent$$1;
  Day.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  Day.prototype.constructor = Day;

  Day.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {
    this.updateState(nextProps);
  };

  Day.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    var props = this.props;
    var state = this.state;

    return props.date !== nextProps.date || props.hoursOfDay !== nextProps.hoursOfDay || props.isWeekend !== nextProps.isWeekend || state.isVisible !== nextState.isVisible;
  };

  Day.prototype.transformState = function transformState (props, context) {
    var isVisible = context.store.isVisibleDate(props.date);

    return {
      isVisible: isVisible
    };
  };

  Day.prototype.getEvents = function getEvents () {
    if (!this.state.isVisible) {
      return null;
    }

    var ref = this.props;
    var date = ref.date;
    var hoursOfDay = ref.hoursOfDay;

    return h(DayEvents, {
      date: date,
      hoursOfDay: hoursOfDay });
  };

  Day.prototype.render = function render () {
    var obj;

    var classes = classnames(( obj = {}, obj[styles$8.Day] = true, obj[styles$8.Day__weekend] = this.props.isWeekend, obj ));

    return h(
      'div',
      { className: classes },
      this.getEvents()
    );
  };

  return Day;
}(StoreComponent));
Day.defaultProps = {
  isWeekend: false
};

var styles$9 = __$injectStyle("2189316770");

/**
 *
 */

var DayHours = (function (StoreComponent$$1) {
  function DayHours () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) DayHours.__proto__ = StoreComponent$$1;
  DayHours.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  DayHours.prototype.constructor = DayHours;

  DayHours.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.state.hoursOfDay !== nextState.hoursOfDay;
  };

  DayHours.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var hoursOfDay = ref.hoursOfDay;
    var HOURS_LIST = ref.HOURS_LIST;
    return { hoursOfDay: hoursOfDay, HOURS_LIST: HOURS_LIST };
  };

  DayHours.prototype.getItems = function getItems () {
    var HOURS_LIST = this.state.HOURS_LIST;

    if (!HOURS_LIST) {
      return null;
    }

    var datetime = this.context.datetime;
    var items = [];

    for (var i = 0, len = HOURS_LIST.length; i < len; i++) {
      var hour$1 = HOURS_LIST[i];

      items.push(h('div', { key: hour$1,
        className: styles$9.DayHours_Item,
        'data-hour': datetime.gridDaysHourTitle(hour$1) }));
    }

    var hour = HOURS_LIST[0];

    items.push(h('div', { key: ("next-" + hour),
      className: styles$9.DayHours_Item,
      'data-hour': datetime.gridDaysHourTitle(hour) }));

    return items;
  };

  DayHours.prototype.render = function render () {
    return h(
      'div',
      { className: styles$9.DayHours },
      this.getItems()
    );
  };

  return DayHours;
}(StoreComponent));

var styles$10 = __$injectStyle("2728098803");

var _class$5;

var GridDaysContent = resize(_class$5 = (function (StoreComponent$$1) {
  function GridDaysContent(props, context) {
    StoreComponent$$1.call(this, props, context);
    this.getItemElement = this.getItemElement.bind(this);
  }

  if ( StoreComponent$$1 ) GridDaysContent.__proto__ = StoreComponent$$1;
  GridDaysContent.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  GridDaysContent.prototype.constructor = GridDaysContent;

  GridDaysContent.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var currentDate = ref.currentDate;
    var gridDaysItemSize = ref.gridDaysItemSize;
    var scaleY = ref.scaleY;
    var scrollY = ref.scrollY;

    return {
      currentDate: currentDate,
      gridDaysItemSize: gridDaysItemSize,
      scaleY: scaleY,
      scrollY: scrollY
    };
  };

  GridDaysContent.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.state.currentDate !== nextState.currentDate || this.state.gridDaysItemSize !== nextState.gridDaysItemSize || this.state.scaleY !== nextState.scaleY || this.state.scrollY !== nextState.scrollY;
  };

  GridDaysContent.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
    StoreComponent$$1.prototype.componentDidUpdate.call(this, prevProps, prevState);

    if (this.state.scaleY !== prevState.scaleY) {
      this.handleResize();
    }
  };

  GridDaysContent.prototype.handleResize = function handleResize () {
    this.context.store.update(this.getRect());
  };

  GridDaysContent.prototype.getItemElement = function getItemElement (offset) {
    var ref = this.state;
    var currentDate = ref.currentDate;
    var gridDaysItemSize = ref.gridDaysItemSize;

    var date = this.context.store.gridDateItemOffset(currentDate, offset);

    return h(GridDaysItem, {
      date: date,
      ItemComponent: Day,
      itemSize: gridDaysItemSize });
  };

  GridDaysContent.prototype.getRect = function getRect () {
    return {
      scrollHeight: this._contentNode.scrollHeight - this._contentNode.clientHeight,
      scrollWidth: this._contentScrollNode.clientWidth
    };
  };

  GridDaysContent.prototype.render = function render () {
    var this$1 = this;

    var style = "\n      transform: translateY(" + (this.state.scrollY) + "px);\n      height: " + (this.state.scaleY) + "%;";

    return h(
      'div',
      { ref: function (node) { return this$1._contentNode = node; },
        className: styles$10.GridDaysContent },
      h(
        'div',
        { ref: function (node) { return this$1._contentScrollNode = node; },
          className: styles$10.GridDaysContent_Scroll,
          style: style },
        h(DayHours, null),
        h(InfiniteList, {
          getItemElement: this.getItemElement })
      )
    );
  };

  return GridDaysContent;
}(StoreComponent))) || _class$5;

var styles$11 = __$injectStyle("4237803930");

var _class$4;

var GridDays = wheel(_class$4 = (function (Component$$1) {
  function GridDays(props, context) {
    Component$$1.call(this, props, context);
    context.store.switchStrategyGridDay();
  }

  if ( Component$$1 ) GridDays.__proto__ = Component$$1;
  GridDays.prototype = Object.create( Component$$1 && Component$$1.prototype );
  GridDays.prototype.constructor = GridDays;

  GridDays.prototype.handleWheel = function handleWheel (deltaX, deltaY) {
    this.context.store.updateScrollByWheel(deltaX, deltaY);
  };

  GridDays.prototype.handleWheelStop = function handleWheelStop () {
    this.context.store.updateScrollByWheel(0, 0);
  };

  GridDays.prototype.render = function render () {
    var this$1 = this;

    return h(
      'table',
      { ref: function (rootNode) { return this$1._rootNode = rootNode; },
        className: styles$11.GridDays },
      h('col', { width: '100%', valign: 'top' }),
      h(
        'thead',
        null,
        h(
          'tr',
          null,
          h(
            'td',
            { className: styles$11.GridDays_Header },
            h(GridDaysHeader, null)
          )
        )
      ),
      h(
        'tbody',
        null,
        h(
          'tr',
          null,
          h(
            'td',
            { className: styles$11.GridDays_Content },
            h(GridDaysContent, null)
          )
        )
      )
    );
  };

  return GridDays;
}(Component))) || _class$4;

var styles$12 = __$injectStyle("213726621");

function MonthWeekDay(ref, ref$1) {
  var date = ref.date;
  var isCurrentDate = ref.isCurrentDate;
  var isWeekend = ref.isWeekend;
  var monthDate = ref.monthDate;
  var trbl = ref.trbl;
  var datetime = ref$1.datetime;
  var isFirstDay = monthDate === 1;

  var classes = [true && styles$12.MonthWeekDay, isWeekend && styles$12.MonthWeekDay__weekend || '', isCurrentDate && styles$12.MonthWeekDay__current || '', trbl && styles$12[("MonthWeekDay__trbl" + trbl)] || ''].join(' ');

  var monthName = isFirstDay ? h(
    'span',
    { className: styles$12.MonthWeekDay_Month },
    datetime.monthNameGenShort(date)
  ) : null;

  return h(
    'div',
    { className: classes },
    h(
      'span',
      { className: styles$12.MonthWeekDay_DateTitle },
      h(
        'span',
        { className: styles$12.MonthWeekDay_Date },
        monthDate
      ),
      monthName
    )
  );
}

var styles$13 = __$injectStyle("1928509998");

var TRBL = {
  B: 2,
  RB: 6,
  T: 8,
  TL: 9
};

function MonthWeekDays(ref, ref$1) {
  var date = ref.date;
  var hideWeekends = ref.hideWeekends;
  var datetime = ref$1.datetime;
  var store = ref$1.store;


  var items = [];
  var trbl = 0;
  var localIdx = 0;

  for (var idx = 0; idx < WEEKDAYS; idx++) {
    var itemDate = datetime.offsetOnDay(date, idx);
    var monthDate = datetime.getDate(itemDate);
    var isWeekend = store.checkWeekend(itemDate);

    if (monthDate === 1) {
      trbl = idx === 0 ? TRBL.T : TRBL.TL;
      for (var i = 0, len = items.length - 1; i <= len; i++) {
        items[i].props.trbl = i === len ? TRBL.RB : TRBL.B;
      }
    } else if (trbl === TRBL.TL) {
      trbl = TRBL.T;
    }

    if (!isWeekend || !hideWeekends) {
      items.push(h(MonthWeekDay, {
        key: localIdx,
        date: itemDate,
        isCurrentDate: isWeekend,
        isWeekend: isWeekend,
        monthDate: monthDate,
        trbl: trbl }));

      localIdx++;
    }
  }

  return h(
    'div',
    { className: styles$13.MonthWeekDays },
    items
  );
}

var styles$14 = __$injectStyle("97797357");

var gridStyles = __$injectStyle("2584529487");

function MonthWeekEvent(ref) {
  var obj;

  var columnEnd = ref.columnEnd;
  var columnStart = ref.columnStart;
  var rowStart = ref.rowStart;
  var classes = classnames(( obj = {}, obj[styles$14.MonthWeekEvent] = true, obj[gridStyles[("Grid_ColumnStart" + columnStart)]] = true, obj[gridStyles[("Grid_ColumnEnd" + columnEnd)]] = columnEnd > columnStart, obj[gridStyles[("Grid_RowStart" + rowStart)]] = true, obj ));

  return h(
    'div',
    { className: classes },
    h(
      'div',
      { className: styles$14.MonthWeekEvent_Content },
      'event 1'
    )
  );
}

var styles$15 = __$injectStyle("1207401694");

var MonthWeekEvents = (function (EventsComponent$$1) {
  function MonthWeekEvents () {
    EventsComponent$$1.apply(this, arguments);
  }

  if ( EventsComponent$$1 ) MonthWeekEvents.__proto__ = EventsComponent$$1;
  MonthWeekEvents.prototype = Object.create( EventsComponent$$1 && EventsComponent$$1.prototype );
  MonthWeekEvents.prototype.constructor = MonthWeekEvents;

  MonthWeekEvents.prototype.transformState = function transformState (props, context) {
    var interval = this.getInterval(props);
    var events = context.events.getByInterval(interval);

    return {
      events: events
    };
  };

  MonthWeekEvents.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.props.date !== nextProps.date || this.props.hideWeekends !== nextProps.hideWeekends
    // this.state.events !== nextState.events // вернуть после Immutable событий
    ;
  };

  MonthWeekEvents.prototype.getInterval = function getInterval (props) {
    if ( props === void 0 ) props = this.props;

    return [props.date, this.context.datetime.offsetOnDay(props.date, WEEKDAYS - 1)];
  };

  MonthWeekEvents.prototype.getItems = function getItems () {
    var items = [];
    return items;
  };

  MonthWeekEvents.prototype.render = function render () {
    var obj;

    var days = 7;
    var rows = 7;
    var classes = classnames(( obj = {}, obj[styles$15.MonthWeekEvents] = true, obj[gridStyles.Grid] = true, obj[gridStyles[("Grid__columns" + days)]] = true, obj[gridStyles[("Grid__rows" + rows)]] = true, obj ));

    return h(
      'div',
      { className: classes },
      h(MonthWeekEvent, {
        rowStart: 1,
        columnStart: 1,
        columnEnd: 2 })
    );
  };

  return MonthWeekEvents;
}(EventsComponent));

var styles$16 = __$injectStyle("197916609");

var MonthWeek = (function (StoreComponent$$1) {
  function MonthWeek () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) MonthWeek.__proto__ = StoreComponent$$1;
  MonthWeek.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  MonthWeek.prototype.constructor = MonthWeek;

  MonthWeek.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {
    this.updateState(nextProps);
  };

  MonthWeek.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    var props = this.props;
    var state = this.state;

    return props.date !== nextProps.date || props.hideWeekends !== nextProps.hideWeekends || props.weekends !== nextProps.weekends || state.isVisible !== nextState.isVisible || state.visibleMonth !== nextState.visibleMonth;
  };

  MonthWeek.prototype.transformState = function transformState (props, context) {
    var isVisible = context.store.isVisibleDate(props.date);

    var ref = context.store.getState();
    var visibleMonth = ref.visibleMonth;
    var speedScrollY = ref.speedScrollY;

    return {
      isVisible: isVisible,
      visibleMonth: visibleMonth,
      speedScrollY: speedScrollY
    };
  };

  MonthWeek.prototype.handleVisible = function handleVisible () {
    this.updateState();
  };

  MonthWeek.prototype.render = function render () {
    var ref = this.props;
    var date = ref.date;
    var hideWeekends = ref.hideWeekends;
    var content = this.state.isVisible ? [h(MonthWeekDays, {
      date: date,
      hideWeekends: hideWeekends }), h(MonthWeekEvents, {
      date: date,
      hideWeekends: hideWeekends })] : null;

    return h(
      'div',
      { className: styles$16.MonthWeek },
      content
    );
  };

  return MonthWeek;
}(StoreComponent));
MonthWeek.defaultProps = {
  date: 0,
  hideWeekends: false,
  weekends: ''
};

var styles$17 = __$injectStyle("3987658384");

var GridMonthItem = (function (StoreComponent$$1) {
  function GridMonthItem () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) GridMonthItem.__proto__ = StoreComponent$$1;
  GridMonthItem.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  GridMonthItem.prototype.constructor = GridMonthItem;

  GridMonthItem.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var hideWeekends = ref.hideWeekends;
    var weekends = ref.weekends;

    return {
      hideWeekends: hideWeekends,
      weekends: weekends
    };
  };

  GridMonthItem.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    var state = this.state;
    var props = this.props;

    return props.date !== nextProps.date || props.itemSize !== nextProps.itemSize || state.hideWeekends !== nextState.hideWeekends || state.weekends !== nextState.weekends;
  };

  GridMonthItem.prototype.getItems = function getItems () {
    var store = this.context.store;
    var ref = this.props;
    var date = ref.date;
    var itemSize = ref.itemSize;
    var ref$1 = this.state;
    var hideWeekends = ref$1.hideWeekends;
    var weekends = ref$1.weekends;
    var items = [];

    var idx = 0;

    while (idx < itemSize) {
      var itemDate = store.gridDateOffset(date, idx);

      items.push(h(MonthWeek, {
        key: idx,
        date: itemDate,
        hideWeekends: hideWeekends,
        weekends: weekends }));

      idx++;
    }

    return items;
  };

  GridMonthItem.prototype.render = function render () {
    return h(
      'div',
      { className: styles$17.GridMonthItem },
      this.getItems()
    );
  };

  return GridMonthItem;
}(StoreComponent));
GridMonthItem.defaultProps = {
  date: 0,
  itemSize: 0
};

var styles$18 = __$injectStyle("1705367372");

var _class$7;

var GridMonthContent = resize(_class$7 = (function (StoreComponent$$1) {
  function GridMonthContent(props, context) {
    StoreComponent$$1.call(this, props, context);
    this.getItemElement = this.getItemElement.bind(this);
  }

  if ( StoreComponent$$1 ) GridMonthContent.__proto__ = StoreComponent$$1;
  GridMonthContent.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  GridMonthContent.prototype.constructor = GridMonthContent;

  GridMonthContent.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var currentDate = ref.currentDate;
    var gridMonthItemSize = ref.gridMonthItemSize;

    return {
      currentDate: currentDate,
      gridMonthItemSize: gridMonthItemSize
    };
  };

  GridMonthContent.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.state.currentDate !== nextState.currentDate || this.state.gridMonthItemSize !== nextState.gridMonthItemSize;
  };

  GridMonthContent.prototype.handleResize = function handleResize () {
    this.context.store.update(this.getRect());
  };

  GridMonthContent.prototype.getItemElement = function getItemElement (offset) {
    var ref = this.state;
    var currentDate = ref.currentDate;
    var gridMonthItemSize = ref.gridMonthItemSize;

    var date = this.context.store.gridDateItemOffset(currentDate, offset);

    return h(GridMonthItem, {
      date: date,
      itemSize: gridMonthItemSize });
  };

  GridMonthContent.prototype.getRect = function getRect () {
    return {
      scrollHeight: this._contentNode.clientHeight,
      scrollWidth: 0
    };
  };

  GridMonthContent.prototype.render = function render () {
    var this$1 = this;

    return h(
      'div',
      { ref: function (node) { return this$1._contentNode = node; },
        className: styles$18.GridMonthContent },
      h(InfiniteList, {
        getItemElement: this.getItemElement })
    );
  };

  return GridMonthContent;
}(StoreComponent))) || _class$7;

var styles$19 = __$injectStyle("3332231429");

var _class$6;

var GridMonth = wheel(_class$6 = (function (Component$$1) {
  function GridMonth(props, context) {
    Component$$1.call(this, props, context);
    context.store.switchStrategyGridMonth();
  }

  if ( Component$$1 ) GridMonth.__proto__ = Component$$1;
  GridMonth.prototype = Object.create( Component$$1 && Component$$1.prototype );
  GridMonth.prototype.constructor = GridMonth;

  GridMonth.prototype.handleWheel = function handleWheel (deltaX, deltaY) {
    this.context.store.updateScrollByWheel(deltaX, deltaY);
  };

  GridMonth.prototype.handleWheelStop = function handleWheelStop () {
    this.context.store.updateScrollByWheel(0, 0);
  };

  GridMonth.prototype.render = function render () {
    var this$1 = this;

    return h(
      'table',
      { ref: function (rootNode) { return this$1._rootNode = rootNode; },
        className: styles$19.GridMonth },
      h('col', { width: '100%', valign: 'top' }),
      h(
        'thead',
        null,
        h(
          'tr',
          null,
          h(
            'td',
            { className: styles$19.GridMonth_Header },
            '1'
          )
        )
      ),
      h(
        'tbody',
        null,
        h(
          'tr',
          null,
          h(
            'td',
            { className: styles$19.GridMonth_Content },
            h(GridMonthContent, null)
          )
        )
      )
    );
  };

  return GridMonth;
}(Component))) || _class$6;

var CalendarGrid = (function (StoreComponent$$1) {
  function CalendarGrid () {
    StoreComponent$$1.apply(this, arguments);
  }

  if ( StoreComponent$$1 ) CalendarGrid.__proto__ = StoreComponent$$1;
  CalendarGrid.prototype = Object.create( StoreComponent$$1 && StoreComponent$$1.prototype );
  CalendarGrid.prototype.constructor = CalendarGrid;

  CalendarGrid.prototype.transformState = function transformState (props, context) {
    var ref = context.store.getState();
    var grid = ref.grid;

    return {
      grid: grid
    };
  };

  CalendarGrid.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {
    return this.state.grid !== nextState.grid;
  };

  CalendarGrid.prototype.render = function render () {
    var ref = this.state;
    var grid = ref.grid;

    return grid === GRID.MONTH ? h(GridMonth, null) : h(GridDays, null);
  };

  return CalendarGrid;
}(StoreComponent));

var styles$20 = __$injectStyle("2155886673");

var Calendar = (function (Component$$1) {
  function Calendar(props, context) {
    Component$$1.call(this, props, context);

    this._store = new CommonStore();
    this._datetime = new Datetime();
    this._events = new Events(new Strategy$1({
      upload: props.upload,
      update: props.update
    }));
  }

  if ( Component$$1 ) Calendar.__proto__ = Component$$1;
  Calendar.prototype = Object.create( Component$$1 && Component$$1.prototype );
  Calendar.prototype.constructor = Calendar;

  Calendar.prototype.getChildContext = function getChildContext () {
    return {
      datetime: this._datetime,
      events: this._events,
      store: this._store
    };
  };

  Calendar.prototype.componentWillReceiveProps = function componentWillReceiveProps (ref) {
    var upload = ref.upload;
    var update = ref.update;

    if (upload !== this.props.upload || update !== this.props.update) {
      this._events.setStrategy(new Strategy$1({
        upload: upload,
        update: update
      }));
    }

    // this._store.update(nextProps);
  };

  Calendar.prototype.componentWillUnmount = function componentWillUnmount () {
    this._datetime.destroy();
    this._events.destroy();
    this._store.destroy();
  };

  Calendar.prototype.render = function render () {
    return h(
      'div',
      { className: styles$20.Calendar },
      h(CalendarGrid, null)
    );
  };

  return Calendar;
}(Component));

Calendar.defaultProps = {};

export { Calendar };
